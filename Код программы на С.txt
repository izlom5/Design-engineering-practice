/*** Программа к проектно-технологической практике (стенд EV8031/AVR) ***
**** Работаем с лампой или моторчиком при помощи ЦАП и линейного регулятора ***
**** В стенд должна быть установлена плата расширения с лампой и моторчиком ***
**** Программа реализует плавное загорание лампы или плавный разгон моторчика ***

!!!! Внимание! Все переключения джамперов выполнять строго при отключенном питании стенда!!!!

/*** Для правильной работы программы на плате расширения должны быть установлены:
/*** - джампер JP3 в положение "Reg", чтобы соединить выход ЦАП со входом линейного регулятора;
/*** - джампер JP2 в положение "Line", чтобы соединить выход линейного регулятора с джампером JP1;
/*** - джампер JP1 в положение "Motor" либо "Lamp", чтобы подключить моторчик или лампу соответственно.

/*** Увеличение/уменьшение значения, которое выводится на ЦАП и определяет яркость лампы 
**** или скорость вращения моторчика производится по прерываниям INT0 & INT1***/

#define F_CPU 7372800L	//задаем частоту кварца (7,3728 МГц)
#include <avr/io.h>
#include <avr/iom8515.h>
#include <avr/interrupt.h>
#include <util/delay.h>

#define led_line 0xA006	//определяем адрес линейки светодиодов в стенде

#define dac_reg 0xF000	//определяем адрес, по которому осуществляется
				//доступ к записи в ЦАП на всех платах расширения

//Объявляем переменную, которая хранит значение яркости ламп или
//скорости вращения моторчика (это значение и подается на ЦАП)
	volatile int currentU= 0;

//Устанавливаем указатель на адрес ЦАП
	volatile unsigned char *dac= (unsigned char*) dac_reg;

//Устанавливаем указатель на адрес линейки светодиодов
	volatile unsigned char *led= (unsigned char*) led_line;
	
//Объявляем вспомогательную переменную - признак того, что нам нужно делать
//Если её значение равно 0xFF, то обрабатывается прерывание IRQ0
//Если её значение равно 0x00, то обрабатывается прерывание IRQ1
//Значение этого признака изменяется в обработчике соответствующего прерывания
		
//массив масок загорания светодиодов
	volatile unsigned char a[6] = {0b00000000, 0b00000001, 0b00000011, 0b00000111, 0b00001111, 0b00011111};
//массив значений напряжения
	volatile unsigned char U[6] = {0x00, 0x33, 0x66, 0x99, 0xCC, 0xFF};

//Прерывания

//Прерывание IRQ0 (по входу INT0)
ISR(INT0_vect){
	if(currentU <5){
		currentU++;
		*dac=U[currentU];
		*led=a[currentU];
	} 
}

		//при заднем фронте
//Прерывание IRQ1 (по входу INT1)
ISR(INT1_vect){
	if (currentU > 0){
		currentU--; 
		*dac=U[currentU]; 
		*led=a[currentU];
	} 
} 

int main(void) {

//начальная инициализация контроллера
	ACSR= 1<<ACD; //отключение питания аналогового компаратора
//разрешаем работу с внешней памятью и настраиваем внешние прерывания
	MCUCR= 1<<SRE | 1<< ISC11 | 0<< ISC10 | 1<<ISC01 | 0<<ISC00;
//прерывания: INT1 вызывается по низкому уровню, а INT0 - по заднему фронту
GICR= 1<<INT0 | 1<<INT1; //разрешаем внешние прерывания INT0 и INT1
//устанавливаем флаг глобального разрешения прерываний
	sei(); //устанавливаем флаг глобального разрешения прерываний (будет работать только INT0 и INT1)

	while(1) {}	//бесконечный цикл (ожидаем прерывания)
	return 0;
}
